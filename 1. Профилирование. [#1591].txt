создал class Main4Profiling
создавал заявки - class CreateManyItems.execute()
запрашивал все заявки - MemTracker.findAll()
удалял все заявки - class DeleteAllItems.execute()

использовал VM options
  - -Xlog:gc*:file=gc.log                     - для логирования
  - -Xlog:gc*:file=gc.log -Xms64m -Xmx128m    - для логирования + добиться состояния выхода за пределы памяти

запускал 
  - на 100 заявок, 
  - на 10 000, 
  - на 1 000 000

выводы: 
  При увеличении нагрузки от 100 до 1,000,000 заявок, использование памяти в куче значительно увеличивается.
  Это указывает на то, что приложение создает больше объектов, которые требуют больше памяти. 

  Увеличивается количество молодых регионов, что говорит о том, что приложение активно создает новые объекты.

  Наличие выживших регионов при 1,000,000 заявок указывает на то, что некоторые объекты пережили сборку мусора.

  Использование метапамяти увеличивается, но остается на низком уровне по сравнению с зарезервированным объемом.

  - на 1 000 000 с ограничением параметров памяти для кучи

Анализ результатов после вызова OutOfMemoryError:

  Ошибка java.lang.OutOfMemoryError: Java heap space: failed reallocation of scalar replaced objects указывает на то, 
  что JVM не смогла выделить достаточно памяти для объектов, которые вы пытались создать.
  Это часто происходит, когда приложение пытается создать больше объектов, чем позволяет максимальный размер кучи.

  Ошибка произошла в методе LocalDateTime.now(), который, вызывается в конструкторе класса Item. Это означает, 
  что при каждой попытке создания нового объекта Item создаётся новый объект LocalDateTime, что требует 
  дополнительной памяти.

выводы: 
  - поскольку достигнут лимита кучи (128MB) нужно увеличить параметры -Xmx
  - если возможно, не нужно каждый раз создавать новый объект LocalDateTime(создать его один раз и использовать повторно)

запускал утилиты:

   - jmap -histo <pid>
выводы: 
  - много классов java.nio.HeapCharBuffer, byte[], java.lang.String, java.time.LocalDateTime
  - объекты класса Item: 1000000 экземпляров, 24000000 байт — это подтверждает, 
  что создаётся значительное количество объектов Item, что приводит к высоким требованиям к памяти

   - jstat -gc pid 1s 10
выводы: 
  - сновная проблема заключается в большом количестве создаваемых объектов, 
  особенно LocalDateTime и Item. Каждый раз, когда создаётся объект Item, 
  создаётся новый объект LocalDateTime, что приводит к высокой нагрузке на память
  - возможно, стоит пересмотреть параметры JVM. Если планируем работать с большим количеством 
  заявок, нужно увеличить максимальный объем кучи (-Xmx), чтобы избежать ошибок OutOfMemory

запускал программу jconsole

  - (Heap Memory Usage)память постепенно увеличивается с 257949696 байт до 262144000 байт.
  Это показывает, что программа использует больше памяти, возможно, из-за создания новых объектов
  - (Threads)в течение наблюдаемого времени количество живых потоков стабильно составляет 16
  - (Classes)количество загруженных классов постепенно увеличивается с 2516 до 2565.
  Это нормально, если приложение создает новые классы в процессе выполнения
  - (CPU Usage)значения использования CPU колеблются, но в целом находятся на низком уровне 

jconsole (VM Summary)  
  - приложение было запущено недавно и использует CPU активно
  - (threads)все потоки активны, и общее количество потоков достигло максимума, 
  что означает, что программа использует все доступные потоки 
  - (classes)программа загружает классы, но не выгружает их, что может быть нормальным для данного состояния приложения 
  - (Heap Memory)используется около 256MB из 3.9GB доступной памяти. Это говорит о том, что памяти достаточно 
  для работы приложения, и оно не исчерпало лимиты
  - (Garbage Collector)сборщик мусора активно работает, очищая молодое поколение, что говорит о нормальном управлении памятью
 